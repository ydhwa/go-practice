# 패키지

Go 프로그램은 한 개이상의 패키지로 구성된다. 각 패키지는 한 개 이상의 Go 소스 파일을 포함하는 폴더이며, 모든 Go 파일은 패키지에 속한다.

패키지 폴더는 `src/` 폴더 하위에 위치하며, 패키지 이름은 모든 Go 파일의 최상단에 선언한다.

패키지명은 소문자로 선언하고, 패키지의 폴더명은 패키지 이름과 동일하게 지정하는 것이 바람직하다.

`import` 키워드로 패키지를 불러올 수 있다.

```go
package mypackage
import "fmt"
```

패키지는 다른 패키지 폴더 안에 존재할 수 있는데, 이런 패키지는 다음과 같이 불러온다.

```go
import "math/rand"
```

한 번에 다수의 패키지를 불러오려면 다음과 같이 사용한다.

```go
import (
    "fmt"
    "math/rand"
)
```

Go 언어에서는 사용하지 않는 패키지를 불러올 수 없는데, 불러온 패키지를 직접적으로 사용하지 않는 경우도 있다. 이런 경우에는 해당 패키지 이름 앞에 `_`를 붙인다.

```go
import (
    "database/sql"
    _"github.com/go-sql-driver/mysql"
)
```


# 컴파일

```bash
# 1. 바이너리를 워크스페이스의 bin 폴더에 생성함
go install
# 2. 바이너리를 현재 폴더에 생성함
go build

# 바이너리 이름과 저장 위치를 직접 지정하여 생성하기
# Windows 운영체제가 아니면 exe 확장자는 무시해도 된다.
go build -o ./output/myexecutable.exe
```


# 변수

```go
// var <변수명> <자료형>
// var 키워드를 사용하면 자료형을 명시적으로 지정할 수 있다.
var s string

// 다수의 변수
var s1, s2, s3 string

// 변수에 초기값 설정
var s1, s2, s3 string = "string1", "string2", "string3"
var s1, s2, s3 = "string1", "string2", "string3"

// 다른 자료형의 변수를 동시에 초기화
var s, i, f = "string", 1, 3.14
var (
    s = "string"
    i = 1
    f = 3.14
)
```

함수 안에서 변수를 선언하고 초기화할 때는 `var` 대신 `:=`를 사용한다.

이는 설정한 값에서 해당 변수의 자료형을 추론하므로 타입 추론(type inference)이라고 한다.

```go
// type inference
s := "string"
i := 1
f := 3.14
```


# 자료형

| 자료형 | 설명 |
| --- | --- |
| `bool` | 불리언 (true \| false) |
| `string` | 문자열은 byte형의 조합이며 문자를 저장한다. 불변(immutable) 타입이기 때문에 문자를 삭제하거나 추가하면 실제로 새로운 문자열을 생성하는 것과 같다. |
| `int, int8, int16, int32, int64` | 부호를 갖는 정수형. 저장할 수 있는 최대 비트를 명시할 수 있다. 일반 int형의 비트 수는 시스템 환경에 따라 선택된다. 대부분의 최신 CPU는 64비트 시스템이다. 소형 및 구형 CPU라면 32비트를 선택한다. |
| `uint, uint8, uint16, uint32, uint64, uintptr` | 부호가 없는 정수형. 부호를 제외하고 부호가 있는 정수형과 비슷하다. uintptr은 메모리 주소를 저장할 수 있는 크기의 부호가 없는 정수형이다. |
| `byte` | uint8과 같다. 크기는 바이트를 나타내는 8비트이다. |
| `rune` | int32와 같다. 보통 Unicode 문자를 나타내려고 사용한다. |
| `float32, float64` | 실수. float32는 32비트까지만 나타내는 작은 실수형이다. |
| `complex64, complex128` | 복소수(complex number)로, 복잡한 수학 연산에 사용한다. complex64는 float32 크기의 실수부와 허수부로 구성된 복소수를 나타낸다. |

## 자료형 별 제로 값

초기값이 없는 변수는 자료형에 따라 다른 제로 값(zero value)이 지정된다.

| 자료형 | 제로값 |
| --- | --- |
| 숫자형 | 0 |
| 불리언 자료형 | false |
| 문자형 | "" |
| 포인터 | nil |


# 포인터

포인터란 변수의 메모리 주소를 저장하는 또 다른 변수이다. 포인터를 사용하면 변수의 값을 복사하지 않고 메모리에 있는 실제 값을 참조할 수 있다.

포인터는 자료형 앞에 `*` 연산자를 붙여 선언한다.

```go
var iptr *int
```

포인터의 제로 값은 nil인데, nil 포인터를 참조하면 에러가 발생한다.

```go
// int형 변수 x 초기화
var x int = 5

// x의 메모리 주소를 가리키는 포인터 선언
var xptr = &x

// xptr 포인터가 가리키는 주소에 저장된 값을 역참조하고 y 변수에 저장
y := *xptr

// 포인터가 가리키는 값 변경
*xptr = 4
```

변수 앞에 `&` 연산자를 붙이면 해당 변수의 메모리 주소를 반환한다.

포인터가 가리키는 주소에 저장된 값을 얻는 행위를 역참조(de-referencing)라고 한다. 포인터가 가리키는 값을 바꿀 때도 역참조를 사용한다.

Go는 일반 포인터의 포인터 연산은 지원하지 않는다. `unsafe` 패키지를 사용하면 가능하지만 꼭 필요한 경우에만 사용하는 것이 좋다.